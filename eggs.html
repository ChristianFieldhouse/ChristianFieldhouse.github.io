<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Egg Carton Optimizer</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Use Inter font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for the range slider thumb */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: #F59E0B; /* amber-500 */
            border-radius: 9999px;
            cursor: pointer;
            border: 2px solid #FFFBEB; /* yellow-50 */
            margin-top: -8px; /* Center thumb */
        }
        input[type=range]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: #F59E0B; /* amber-500 */
            border-radius: 9999px;
            cursor: pointer;
            border: 2px solid #FFFBEB; /* yellow-50 */
        }
        input[type=range]::-ms-thumb {
            width: 24px;
            height: 24px;
            background: #F59E0B; /* amber-500 */
            border-radius: 9999px;
            cursor: pointer;
            border: 2px solid #FFFBEB; /* yellow-50 */
        }
    </style>
</head>
<body class="bg-yellow-50 min-h-screen text-gray-800 p-4 md:p-8">

    <!-- Main Content Card -->
    <div class="max-w-3xl mx-auto bg-white p-6 md:p-8 rounded-3xl shadow-lg border-4 border-yellow-200">
        
        <!-- Header -->
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-amber-600 mb-2">Egg Carton Optimizer</h1>
            <p class="text-lg text-gray-600">Find the most stable way to pack your eggs!</p>
        </header>

        <!-- Controls -->
        <div class="mb-6 grid grid-cols-1 md:grid-cols-2 gap-6">
            <!-- Carton Size Controls -->
            <div class="bg-gray-100 p-4 rounded-xl shadow-inner">
                <label class="block text-sm font-medium text-gray-700 mb-2">Carton Dimensions</label>
                <div class="flex items-center gap-4">
                    <input type="number" id="rowsInput" value="2" min="1" max="6" class="w-full rounded-lg border-gray-300 shadow-sm focus:border-yellow-500 focus:ring focus:ring-yellow-200 focus:ring-opacity-50">
                    <span class="text-gray-500 font-bold">×</span>
                    <input type="number" id="colsInput" value="6" min="1" max="10" class="w-full rounded-lg border-gray-300 shadow-sm focus:border-yellow-500 focus:ring focus:ring-yellow-200 focus:ring-opacity-50">
                </div>
            </div>
            
            <!-- Egg Count Control -->
            <div class="bg-gray-100 p-4 rounded-xl shadow-inner">
                <label for="eggsSlider" class="flex justify-between text-sm font-medium text-gray-700 mb-2">
                    <span>Number of Eggs</span>
                    <span id="eggCountLabel" class="font-bold text-amber-600">6</span>
                </label>
                <input type="range" id="eggsSlider" min="0" max="12" value="6" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer range-lg">
            </div>
        </div>
        
        <!-- Calculation Warning -->
        <div id="warningMessage" class="hidden text-center text-red-600 font-medium mb-4 p-3 bg-red-100 rounded-lg">
            Carton is too large to compute! (Max 20 cells)
        </div>

        <!-- Egg Carton Visualization -->
        <div id="cartonGrid" class="grid gap-2 p-4 bg-gray-200 rounded-2xl shadow-inner mb-6" style="grid-template-columns: repeat(6, 1fr);">
            <!-- Egg cells will be generated by JS -->
        </div>
        
        <!-- Explanation & Stats -->
        <div class="bg-yellow-100 p-6 rounded-2xl border-2 border-yellow-200">
            <h2 class="text-xl font-bold text-amber-700 mb-3">How this works:</h2>
            <p class="text-gray-700 mb-4">
                This finds the most stable arrangement by:
            </p>
            <ol class="list-decimal list-inside space-y-2 mb-4">
                <li>Finding all arrangements that place the combined (eggs + cardboard) <strong>Center of Gravity (CG)</strong> closest to the geometric center.</li>
                <li>Calculating the <strong>Principal Moments of Inertia</strong> (<strong>I_min</strong> & <strong>I_max</strong>) for each of those.</li>
                <li>Selecting the arrangement that <strong>maximizes the product (<strong>I_min × I_max</strong>)</strong> for the most balanced stability.</li>
            </ol>
            <div class="grid grid-cols-3 gap-4 pt-4 border-t border-yellow-300">
                <div class="text-center">
                    <span class="block text-sm text-gray-600">CG Distance</span>
                    <span id="cgDist" class="text-2xl font-bold text-amber-600">0.000</span>
                </div>
                <div class="text-center">
                    <span class="block text-sm text-gray-600">Min MOI (<strong>I_min</strong>)</span>
                    <span id="moiMinVal" class="text-2xl font-bold text-amber-600">0.0</span>
                </div>
                <div class="text-center">
                    <span class="block text-sm text-gray-600">Max MOI (<strong>I_max</strong>)</span>
                    <span id="moiMaxVal" class="text-2xl font-bold text-amber-600">0.0</span>
                </div>
            </div>
        </div>

    </div>

    <script>
        // --- DOM Elements ---
        const rowsInput = document.getElementById('rowsInput');
        const colsInput = document.getElementById('colsInput');
        const eggsSlider = document.getElementById('eggsSlider');
        const eggCountLabel = document.getElementById('eggCountLabel');
        const cartonGrid = document.getElementById('cartonGrid');
        const cgDist = document.getElementById('cgDist');
        const moiMinVal = document.getElementById('moiMinVal');
        const moiMaxVal = document.getElementById('moiMaxVal');
        const warningMessage = document.getElementById('warningMessage');
        
        // --- Constants ---
        const EPSILON = 1e-9;
        const MAX_CELLS = 20; // Safety limit for combinations
        const M_EGG = 1.0;    // Mass of one egg
        const M_CELL = 0.01;  // Mass of one cardboard cell

        // --- Core Logic ---

        /**
         * Generates all combinations of k elements from an array.
         */
        function getCombinations(arr, k) {
            if (k === 0) return [[]];
            if (k > arr.length || arr.length === 0) return [];
            
            const first = arr[0];
            const rest = arr.slice(1);
            
            const combsWithFirst = getCombinations(rest, k - 1).map(comb => [first, ...comb]);
            const combsWithoutFirst = getCombinations(rest, k);
            
            return [...combsWithFirst, ...combsWithoutFirst];
        }

        /**
         * Generates a list of all cell coordinates relative to the geometric center.
         */
        function generateCellCoordinates(R, C) {
            const cells = [];
            const centerX = (C - 1) / 2;
            const centerY = (R - 1) / 2;
            
            for (let r = 0; r < R; r++) {
                for (let c = 0; c < C; c++) {
                    cells.push({
                        r: r,
                        c: c,
                        x: c - centerX, // Coordinate for y-axis moment
                        y: r - centerY  // Coordinate for x-axis moment
                    });
                }
            }
            return cells;
        }

        /**
         * Finds the best arrangement based on combined CG and max(I_min * I_max).
         */
        function calculateBestArrangement(R, C, N) {
            const totalCells = R * C;
            if (N > totalCells) N = totalCells;

            const allCells = generateCellCoordinates(R, C);
            
            // Handle N=0 case
            if (N === 0) {
                const { moi_min, moi_max } = calculatePrincipalMOI(R, C, [], allCells, 0, 0);
                return { arrangement: [], cgDist: 0, moi_min, moi_max };
            }

            const allArrangements = getCombinations(allCells, N);
            
            // --- Step 1: Find best Combined Center of Gravity ---
            let minCGDist = Infinity;
            let bestCGResults = [];
            
            const M_cardboard = (R * C) * M_CELL;
            const M_eggs = N * M_EGG;
            const M_total = M_cardboard + M_eggs;

            for (const arr of allArrangements) {
                let sumEx = 0; // Egg moment sum about geometric y-axis
                let sumEy = 0; // Egg moment sum about geometric x-axis
                
                for (const cell of arr) {
                    sumEx += cell.x;
                    sumEy += cell.y;
                }
                
                // CG of combined system (cardboard CG is at (0,0))
                const cgX = (sumEx * M_EGG) / M_total;
                const cgY = (sumEy * M_EGG) / M_total;
                const cgDist = Math.sqrt(cgX * cgX + cgY * cgY);
                
                const result = { arr, cgDist, cgX, cgY };

                if (cgDist < minCGDist - EPSILON) {
                    minCGDist = cgDist;
                    bestCGResults = [result];
                } else if (Math.abs(cgDist - minCGDist) < EPSILON) {
                    bestCGResults.push(result);
                }
            }
            
            // --- Step 2: Find max(I_min * I_max) from the best CG group ---
            let max_product = -1;
            let finalBestArrangement = bestCGResults[0].arr;
            let finalStats = { cgDist: minCGDist, moi_min: 0, moi_max: 0 };

            for (const result of bestCGResults) {
                const { arr, cgX, cgY } = result;
                
                const { moi_min, moi_max } = calculatePrincipalMOI(R, C, arr, allCells, cgX, cgY);
                const product = moi_min * moi_max;

                if (product > max_product) {
                    max_product = product;
                    finalBestArrangement = arr;
                    finalStats = { cgDist: result.cgDist, moi_min, moi_max };
                }
            }
            
            return { arrangement: finalBestArrangement, ...finalStats };
        }
        
        /**
         * Calculates the Principal Moments of Inertia (I_min, I_max) for the system.
         */
        function calculatePrincipalMOI(R, C, eggArrangement, allCells, cgX, cgY) {
            let I_xx = 0; // MOI about x-axis: Σm(y - cgY)²
            let I_yy = 0; // MOI about y-axis: Σm(x - cgX)²
            let I_xy = 0; // Product of Inertia: Σm(x - cgX)(y - cgY)
            
            // 1. Cardboard contribution
            for (const cell of allCells) {
                const dx = cell.x - cgX;
                const dy = cell.y - cgY;
                I_xx += M_CELL * dy * dy;
                I_yy += M_CELL * dx * dx;
                I_xy += M_CELL * dx * dy;
            }
            
            // 2. Egg contribution
            for (const cell of eggArrangement) {
                const dx = cell.x - cgX;
                const dy = cell.y - cgY;
                I_xx += M_EGG * dy * dy;
                I_yy += M_EGG * dx * dx;
                I_xy += M_EGG * dx * dy;
            }

            // 3. Calculate eigenvalues of the inertia tensor
            // Tensor is: [ I_xx  -I_xy ]
            //             [ -I_xy  I_yy ]
            // (Note: Using physics convention where I_xx = Σm(y²+z²) and I_yy = Σm(x²+z²).
            // For our 2D plane, z=0, so I_xx = Σmy² and I_yy = Σmx².)
            
            // Characteristic equation:
            // (I_xx - λ)(I_yy - λ) - (-I_xy)² = 0
            // λ² - (I_xx + I_yy)λ + (I_xx*I_yy - I_xy²) = 0
            
            const I_sum = I_xx + I_yy;
            const discriminant = Math.sqrt(Math.pow(I_xx - I_yy, 2) + 4 * I_xy * I_xy);
            
            const moi_1 = (I_sum + discriminant) / 2;
            const moi_2 = (I_sum - discriminant) / 2;
            
            return {
                moi_min: Math.min(moi_1, moi_2),
                moi_max: Math.max(moi_1, moi_2)
            };
        }

        /**
         * Renders the egg carton grid.
         */
        function renderGrid(R, C, bestArrangement) {
            cartonGrid.innerHTML = '';
            cartonGrid.style.gridTemplateColumns = `repeat(${C}, 1fr)`;
            
            const occupiedCells = new Set(
                bestArrangement.map(cell => `${cell.r}-${cell.c}`)
            );
            
            for (let r = 0; r < R; r++) {
                for (let c = 0; c < C; c++) {
                    const cell = document.createElement('div');
                    const isOccupied = occupiedCells.has(`${r}-${c}`);
                    
                    let classes = 'aspect-square rounded-full flex items-center justify-center text-3xl md:text-4xl transition-all duration-300 transform';
                    
                    if (isOccupied) {
                        classes += ' bg-yellow-100 border-2 border-yellow-300 shadow-md scale-105';
                        cell.innerHTML = '🥚';
                    } else {
                        classes += ' bg-gray-300 opacity-50';
                    }
                    
                    cell.className = classes;
                    cartonGrid.appendChild(cell);
                }
            }
        }
        
        /**
         * Main function to update the entire visualization.
         */
        function updateVisualization() {
            const R = parseInt(rowsInput.value) || 1;
            const C = parseInt(colsInput.value) || 1;
            const totalCells = R * C;
            
            // --- Safety Check ---
            if (totalCells > MAX_CELLS) {
                cartonGrid.innerHTML = '';
                warningMessage.classList.remove('hidden');
                cgDist.textContent = '---';
                moiMinVal.textContent = '---';
                moiMaxVal.textContent = '---';
                eggsSlider.disabled = true;
                return;
            } else {
                warningMessage.classList.add('hidden');
                eggsSlider.disabled = false;
            }
            
            // Update slider
            eggsSlider.max = totalCells;
            let N = parseInt(eggsSlider.value);
            if (N > totalCells) {
                N = totalCells;
                eggsSlider.value = N;
            }
            eggCountLabel.textContent = N;
            
            // --- Calculate and Render ---
            const { arrangement, cgDist: cg, moi_min, moi_max } = calculateBestArrangement(R, C, N);
            
            renderGrid(R, C, arrangement);
            
            // Update stats
            cgDist.textContent = cg.toFixed(3);
            moiMinVal.textContent = moi_min.toFixed(1);
            moiMaxVal.textContent = moi_max.toFixed(1);
        }
        
        // --- Event Listeners ---
        rowsInput.addEventListener('input', updateVisualization);
        colsInput.addEventListener('input', updateVisualization);
        eggsSlider.addEventListener('input', updateVisualization);
        
        // Initial load
        window.addEventListener('DOMContentLoaded', updateVisualization);
    </script>
</body>
</html>


