<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Egg Carton Optimizer</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Use Inter font as requested */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for the range slider thumb to match the theme */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background: #F59E0B; /* amber-500 */
            border-radius: 9999px;
            cursor: pointer;
            border: 2px solid #FFFBEB; /* yellow-50 */
            margin-top: -8px; /* Center thumb */
        }
        input[type=range]::-moz-range-thumb {
            width: 24px;
            height: 24px;
            background: #F59E0B; /* amber-500 */
            border-radius: 9999px;
            cursor: pointer;
            border: 2px solid #FFFBEB; /* yellow-50 */
        }
        input[type=range]::-ms-thumb {
            width: 24px;
            height: 24px;
            background: #F59E0B; /* amber-500 */
            border-radius: 9999px;
            cursor: pointer;
            border: 2px solid #FFFBEB; /* yellow-50 */
        }
    </style>
</head>
<body class="bg-yellow-50 min-h-screen text-gray-800 p-4 md:p-8">

    <!-- Main Content Card -->
    <div class="max-w-3xl mx-auto bg-white p-6 md:p-8 rounded-3xl shadow-lg border-4 border-yellow-200">
        
        <!-- Header -->
        <header class="text-center mb-6">
            <h1 class="text-3xl md:text-4xl font-bold text-amber-600 mb-2">Egg Carton Optimizer</h1>
            <p class="text-lg text-gray-600">Find the most stable way to pack your eggs!</p>
        </header>

        <!-- Controls -->
        <div class="mb-6 grid grid-cols-1 md:grid-cols-2 gap-6">
            <!-- Carton Size Controls -->
            <div class="bg-gray-100 p-4 rounded-xl shadow-inner">
                <label class="block text-sm font-medium text-gray-700 mb-2">Carton Dimensions</label>
                <div class="flex items-center gap-4">
                    <input type="number" id="rowsInput" value="2" min="1" max="6" class="w-full rounded-lg border-gray-300 shadow-sm focus:border-yellow-500 focus:ring focus:ring-yellow-200 focus:ring-opacity-50">
                    <span class="text-gray-500 font-bold">Ã—</span>
                    <input type="number" id="colsInput" value="6" min="1" max="10" class="w-full rounded-lg border-gray-300 shadow-sm focus:border-yellow-500 focus:ring focus:ring-yellow-200 focus:ring-opacity-50">
                </div>
            </div>
            
            <!-- Egg Count Control -->
            <div class="bg-gray-100 p-4 rounded-xl shadow-inner">
                <label for="eggsSlider" class="flex justify-between text-sm font-medium text-gray-700 mb-2">
                    <span>Number of Eggs</span>
                    <span id="eggCountLabel" class="font-bold text-amber-600">6</span>
                </label>
                <input type="range" id="eggsSlider" min="0" max="12" value="6" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer range-lg">
            </div>
        </div>
        
        <!-- Calculation Warning -->
        <div id="warningMessage" class="hidden text-center text-red-600 font-medium mb-4 p-3 bg-red-100 rounded-lg">
            Carton is too large to compute! (Max 20 cells)
        </div>

        <!-- Egg Carton Visualization -->
        <div id="cartonGrid" class="grid gap-2 p-4 bg-gray-200 rounded-2xl shadow-inner mb-6" style="grid-template-columns: repeat(6, 1fr);">
            <!-- Egg cells will be generated by JS -->
        </div>
        
        <!-- Explanation & Stats -->
        <div class="bg-yellow-100 p-6 rounded-2xl border-2 border-yellow-200">
            <h2 class="text-xl font-bold text-amber-700 mb-3">How this works:</h2>
            <p class="text-gray-700 mb-4">
                This finds the most stable arrangement by following two physics principles:
            </p>
            <ol class="list-decimal list-inside space-y-2 mb-4">
                <li>First, it finds all arrangements with the <strong>Center of Gravity (CG)</strong> as close as possible to the carton's geometric center.</li>
                <li>Then, from that "best CG" group, it picks the arrangement with the <strong>Maximum Moment of Inertia (MOI)</strong>, which makes it more resistant to tipping.</li>
            </ol>
            <div class="grid grid-cols-2 gap-4 pt-4 border-t border-yellow-300">
                <div class="text-center">
                    <span class="block text-sm text-gray-600">CG Distance</span>
                    <span id="cgDist" class="text-2xl font-bold text-amber-600">0.000</span>
                </div>
                <div class="text-center">
                    <span class="block text-sm text-gray-600">Moment of Inertia</span>
                    <span id="moiVal" class="text-2xl font-bold text-amber-600">0.0</span>
                </div>
            </div>
        </div>

    </div>

    <script>
        // --- DOM Elements ---
        const rowsInput = document.getElementById('rowsInput');
        const colsInput = document.getElementById('colsInput');
        const eggsSlider = document.getElementById('eggsSlider');
        const eggCountLabel = document.getElementById('eggCountLabel');
        const cartonGrid = document.getElementById('cartonGrid');
        const cgDist = document.getElementById('cgDist');
        const moiVal = document.getElementById('moiVal');
        const warningMessage = document.getElementById('warningMessage');
        
        // Epsilon for floating point comparisons
        const EPSILON = 1e-9;
        // Max cells to compute to avoid freezing the browser
        const MAX_CELLS = 20;

        // --- Core Logic ---

        /**
         * Generates all combinations of k elements from an array.
         * @param {Array} arr - The source array.
         * @param {number} k - The number of elements to choose.
         * @returns {Array<Array>} An array of all combinations.
         */
        function getCombinations(arr, k) {
            if (k === 0) return [[]];
            if (k > arr.length || arr.length === 0) return [];
            
            const first = arr[0];
            const rest = arr.slice(1);
            
            const combsWithFirst = getCombinations(rest, k - 1).map(comb => [first, ...comb]);
            const combsWithoutFirst = getCombinations(rest, k);
            
            return [...combsWithFirst, ...combsWithoutFirst];
        }

        /**
         * Generates a list of all cell coordinates relative to the center.
         * @param {number} R - Rows
         * @param {number} C - Columns
         * @returns {Array<Object>} List of cell objects {r, c, x, y}
         */
        function generateCellCoordinates(R, C) {
            const cells = [];
            const centerX = (C - 1) / 2;
            const centerY = (R - 1) / 2;
            
            for (let r = 0; r < R; r++) {
                for (let c = 0; c < C; c++) {
                    cells.push({
                        r: r,
                        c: c,
                        x: c - centerX,
                        y: r - centerY
                    });
                }
            }
            return cells;
        }

        /**
         * Calculates the Center of Gravity (CG) for an arrangement.
         * @param {Array<Object>} arrangement - List of cell objects.
         * @returns {Object} { cgX, cgY, dist }
         */
        function calculateCG(arrangement) {
            if (arrangement.length === 0) {
                return { cgX: 0, cgY: 0, dist: 0 };
            }
            
            let sumX = 0;
            let sumY = 0;
            
            for (const cell of arrangement) {
                sumX += cell.x;
                sumY += cell.y;
            }
            
            const cgX = sumX / arrangement.length;
            const cgY = sumY / arrangement.length;
            const dist = Math.sqrt(cgX * cgX + cgY * cgY);
            
            return { cgX, cgY, dist };
        }

        /**
         * Calculates the Moment of Inertia (MOI) for an arrangement.
         * @param {Array<Object>} arrangement - List of cell objects.
         * @returns {number} The MOI.
         */
        function calculateMOI(arrangement) {
            let moi = 0;
            for (const cell of arrangement) {
                // MOI = sum(m * r^2). Assuming m=1 for all eggs.
                // r^2 = x^2 + y^2
                moi += (cell.x * cell.x) + (cell.y * cell.y);
            }
            return moi;
        }

        /**
         * Finds the best arrangement based on CG and MOI.
         * @param {number} R - Rows
         * @param {number} C - Columns
         * @param {number} N - Number of eggs
         * @returns {Object} { arrangement, cgDist, moi }
         */
        function calculateBestArrangement(R, C, N) {
            const totalCells = R * C;
            if (N === 0) {
                return { arrangement: [], cgDist: 0, moi: 0 };
            }
            if (N > totalCells) {
                N = totalCells;
            }

            const allCells = generateCellCoordinates(R, C);
            
            if (N === totalCells) {
                const cg = calculateCG(allCells);
                const moi = calculateMOI(allCells);
                return { arrangement: allCells, cgDist: cg.dist, moi: moi };
            }

            // Get all possible arrangements
            const allArrangements = getCombinations(allCells, N);
            
            // --- Step 1: Find best Center of Gravity ---
            let minCGDist = Infinity;
            let bestCGArrangements = [];

            for (const arr of allArrangements) {
                const cg = calculateCG(arr);
                
                if (cg.dist < minCGDist - EPSILON) {
                    // Found a new best
                    minCGDist = cg.dist;
                    bestCGArrangements = [arr];
                } else if (Math.abs(cg.dist - minCGDist) < EPSILON) {
                    // Equally good CG
                    bestCGArrangements.push(arr);
                }
            }
            
            // --- Step 2: Find max Moment of Inertia from the best CG group ---
            let maxMOI = -1;
            let finalBestArrangement = [];

            if (bestCGArrangements.length === 0 && allArrangements.length > 0) {
                // Fallback, though this shouldn't happen
                bestCGArrangements = [allArrangements[0]];
            }

            for (const arr of bestCGArrangements) {
                const moi = calculateMOI(arr);
                if (moi > maxMOI) {
                    maxMOI = moi;
                    finalBestArrangement = arr;
                }
            }

            return { arrangement: finalBestArrangement, cgDist: minCGDist, moi: maxMOI };
        }

        /**
         * Renders the egg carton grid.
         * @param {number} R - Rows
         * @param {number} C - Columns
         * @param {Array<Object>} bestArrangement - The arrangement to display.
         */
        function renderGrid(R, C, bestArrangement) {
            cartonGrid.innerHTML = '';
            cartonGrid.style.gridTemplateColumns = `repeat(${C}, 1fr)`;
            
            const occupiedCells = new Set(
                bestArrangement.map(cell => `${cell.r}-${cell.c}`)
            );
            
            for (let r = 0; r < R; r++) {
                for (let c = 0; c < C; c++) {
                    const cell = document.createElement('div');
                    const isOccupied = occupiedCells.has(`${r}-${c}`);
                    
                    let classes = 'aspect-square rounded-full flex items-center justify-center text-3xl md:text-4xl transition-all duration-300 transform';
                    
                    if (isOccupied) {
                        classes += ' bg-yellow-100 border-2 border-yellow-300 shadow-md scale-105';
                        cell.innerHTML = 'ðŸ¥š';
                    } else {
                        classes += ' bg-gray-300 opacity-50';
                    }
                    
                    cell.className = classes;
                    cartonGrid.appendChild(cell);
                }
            }
        }
        
        /**
         * Main function to update the entire visualization.
         */
        function updateVisualization() {
            const R = parseInt(rowsInput.value) || 1;
            const C = parseInt(colsInput.value) || 1;
            const totalCells = R * C;
            
            // --- Safety Check ---
            if (totalCells > MAX_CELLS) {
                cartonGrid.innerHTML = '';
                warningMessage.classList.remove('hidden');
                cgDist.textContent = '---';
                moiVal.textContent = '---';
                eggsSlider.disabled = true;
                return;
            } else {
                warningMessage.classList.add('hidden');
                eggsSlider.disabled = false;
            }
            
            // Update slider
            eggsSlider.max = totalCells;
            let N = parseInt(eggsSlider.value);
            if (N > totalCells) {
                N = totalCells;
                eggsSlider.value = N;
            }
            eggCountLabel.textContent = N;
            
            // --- Calculate and Render ---
            const { arrangement, cgDist: cg, moi } = calculateBestArrangement(R, C, N);
            
            renderGrid(R, C, arrangement);
            
            // Update stats
            cgDist.textContent = cg.toFixed(3);
            moiVal.textContent = moi.toFixed(1);
        }
        
        // --- Event Listeners ---
        rowsInput.addEventListener('input', updateVisualization);
        colsInput.addEventListener('input', updateVisualization);
        eggsSlider.addEventListener('input', updateVisualization);
        
        // Initial load
        window.addEventListener('DOMContentLoaded', updateVisualization);
    </script>
</body>
</html>

